#include <reg932.inc>

cseg at 0

        mov p2m1,#0		; configure Port 2 as bi-directional
        mov p1m1,#0		; configure Port 1 as bi-directional
        mov p0m1,#0		; configure Port 0 as bi-directional
        
        mov r0, #00h            ; initialise r0

; button listener
loop:	mov c,p1.4		; move switch _ to c flag
	jnc increment		; jump to increment label if __ pressed
	mov c,p0.0		; move switch _ to c flag      
	jnc decrement		; jump to decrement label if __ pressed
        mov c,p2.2		; move switch _ to c flag
	jnc togglebit0		; jump to togglebit0 label if __ pressed
	mov c,p0.3		; move switch _ to c flag      
	jnc togglebit1		; jump to togglebit1 label if __ pressed
        mov c,p2.1		; move switch _ to c flag
	jnc togglebit2		; jump to togglebit2 label if __ pressed
	mov c,p0.2		; move switch _ to c flag      
	jnc togglebit3		; jump to togglebit3 label if __ pressed
        mov c,p2.0		; move switch _ to c flag      
	jnc multiply			; jump to __ label if __ pressed
        mov c,p_._		; move switch _ to c flag
	jnc __			; jump to __ label if __ pressed
	mov c,p_._		; move switch _ to c flag      
	jnc __			; jump to __ label if __ pressed
	sjmp loop		; jump back



; decrement 
decrement:
        dec r0                  ; decrement r0
        sjmp check  ; short jump to check 

; increment or multiply
increment:
        inc r0                  ; increment r0
        sjmp check ; short jumps check
	
	
multiply:  mov A, R0            ; mov data to Acc    
           add R0, A            ; adding r0 and accumulator is same as multiplying by 2
           sjmp check           ; checks for overflow/underflow
           jb display           ; jumps to display
	   jnz multiply         ; jumps back to multiply if it doesn't equal 0
	   sjmp check           ; jumps to check
	   
	   

check:  mov A, r0		; grabs 5th bit from register 0
	jb ACC.4, alarm
	jb ACC.7, alarm
	sjmp display
	
alarm:	ANL r0,#0Fh             ; clears over/underflow. if ACC.7 is 1 then it makes r0 equal 15
	mov r5,#3        	; emit alarm sound 4 times
again0:	mov r6,#30
again1:	cpl p1.7
	lcall delay
	djnz r6,again1
	djnz r5,again0
	sjmp display
	
sound:	mov r3,r0
	mov r4,#255
	cpl p1.7
	lcall delay
	djnz R4, again
	sjmp loop



	

	   
display:   mov A, R0            ; mov data to acc
           CPL A                ; invert the data because active low 
           mov p2.6, acc.0      ; LED9
           mov 0.7, acc.1       ; LED8
           mov 2.5, acc.2       ; LED7
           mov 0.6, acc.3       ; LED6
           sjmp blink           ; jumps to sound






delay:
	mov R2,#40		; initial value for delayLoop1
delayLoop1:			; start of delayLoop1
	ADD r3,#13
	mov R1,R3		; delayLoop0 depends on binary number
delayLoop0:			; start of delayLoop1
	nop			; takes 1 machine cycle
	djnz R1,delayLoop0	; end of delayLoop0
	djnz R2,delayLoop1	; end of delayLoop1
	ret



; blinkes amount in r0
blink:	mov A,R0
	mov R6,A
bloop:	clr p0.4
	lcall delayb	
 	setb p0.4
	lcall delayb
	djnz R6, bloop
	sjmp sound
	
delayb:				
	mov R3,#10		
delayb2:			
	mov R2,#100		
delayb1:			
	mov R1,#255		
delayb0:		
	nop			
	nop			
	djnz R1,delayb0	
	djnz R2,delayb1	
	djnz R3,delayb2	
	ret


      
     
        
; togglebit
togglebit0:
        mov A, R0               ; mov data to Acc
        xrl A, #01h             ; togglebit 0
        mov R0, A               ; store data in R0
        sjmp display
togglebit1:
        mov A, R0               ; mov data to Acc
        xrl A, #02h             ; togglebit 1
        mov R0, A               ; store data in R0
        sjmp display
togglebit2:
        mov A, R0               ; mov data to Acc
        xrl A, #04h             ; togglebit 2
        mov R0, A               ; store data in R0
        sjmp display
togglebit3:
        mov A, R0               ; mov data to Acc
        xrl A, #08h             ; togglebit 3
        mov R0, A               ; store data in R0
        sjmp display
end
